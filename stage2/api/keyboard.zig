/// Abstraction over key codes returned by a keyboard interface
pub const Scancode = enum(u8) {
    pub fn printable(this: *const Scancode, shift: bool) ?u8 {
        const nums = "1234567890";
        const s_nums = "!@#$%^&*()";
        const alpha = "abcdefghijklmnopqrstuvwxyz";
        const s_alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        const this_int = @intFromEnum(this.*);

        if (this_int >= @intFromEnum(Scancode.ch_1) and this_int <= @intFromEnum(Scancode.ch_0)) {
            const index = this_int - @intFromEnum(Scancode.ch_1);
            if (shift) return s_nums[index];
            return nums[index];
        } else if (this_int >= @intFromEnum(Scancode.ch_a) and this_int <= @intFromEnum(Scancode.ch_z)) {
            const index = this_int - @intFromEnum(Scancode.ch_a);
            if (shift) return s_alpha[index];
            return alpha[index];
        } else return switch (this.*) {
            .space => ' ',
            .back_tick => if (shift) '~' else '`',
            .period => if (shift) '>' else '.',
            .comma => if (shift) '<' else ',',
            .slash => if (shift) '?' else '/',
            .semicolon => if (shift) ':' else ';',
            .apostrophe => if (shift) '"' else '\'',
            .minus => if (shift) '_' else '-',
            .bracket_left => if (shift) '{' else '[',
            .bracket_right => if (shift) '}' else ']',
            .backslash => if (shift) '|' else '\\',
            .equals => if (shift) '+' else '=',
            else => null,
        };
    }

    invalid,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    tab,
    alt_left,
    shift_left,
    control_left,
    alt_right,
    shift_right,
    control_right,
    caps_lock,
    enter,
    backspace,
    escape,
    number_lock,
    scroll_lock,
    ch_1,
    ch_2,
    ch_3,
    ch_4,
    ch_5,
    ch_6,
    ch_7,
    ch_8,
    ch_9,
    ch_0,
    ch_a,
    ch_b,
    ch_c,
    ch_d,
    ch_e,
    ch_f,
    ch_g,
    ch_h,
    ch_i,
    ch_j,
    ch_k,
    ch_l,
    ch_m,
    ch_n,
    ch_o,
    ch_p,
    ch_q,
    ch_r,
    ch_s,
    ch_t,
    ch_u,
    ch_v,
    ch_w,
    ch_x,
    ch_y,
    ch_z,
    back_tick,
    space,
    period,
    comma,
    slash,
    semicolon,
    apostrophe,
    minus,
    bracket_left,
    bracket_right,
    backslash,
    equals,
    kp_0,
    kp_1,
    kp_2,
    kp_3,
    kp_4,
    kp_5,
    kp_6,
    kp_7,
    kp_8,
    kp_9,
    kp_period,
    kp_plus,
    kp_minus,
    kp_asterisk,
    kp_slash,
    kp_enter,
    multimedia_search,
    multimedia_previous_track,
    multimedia_favorites,
    multimedia_refresh,
    multimedia_volume_up,
    multimedia_volume_down,
    multimedia_mute,
    multimedia_forward,
    multimedia_back,
    multimedia_stop,
    multimedia_calculator,
    multimedia_pause,
    multimedia_home,
    multimedia_computer,
    multimedia_email,
    multimedia_next_track,
    multimedia_select,
    acpi_wake,
    acpi_sleep,
    acpi_power,
    left_gui,
    right_gui,
    apps,
    print_screen,
    pause,
    end,
    up,
    down,
    left,
    right,
    home,
    insert,
    delete,
    page_up,
    page_down,
};

/// Stores both a scancode and whether it was pressed or released
pub const KeyEvent = struct {
    pub const EventType = enum { pressed, released };
    pub const Modifiers = struct {
        alt: bool = false,
        ctrl: bool = false,
        shift: bool = false,
    };

    code: Scancode = .invalid,
    event_type: EventType = .pressed,
    modifiers: Modifiers = .{},
};

pub const KeyboardInfo = struct {
    init: ?*const fn () anyerror!void,
    getInput: *const fn () ?KeyEvent,
    deinit: ?*const fn () anyerror!void,
};
